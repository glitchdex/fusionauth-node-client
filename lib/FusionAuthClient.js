/*
 * Copyright (c) 2018-2019, FusionAuth, All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

'use strict';

const RESTClient = require('./RESTClient.js');
var Promise = require('promise');

const FusionAuthClient = function(apiKey, host) {
  this.apiKey = apiKey;
  this.host = host;
  this.tenantId = null;
};

FusionAuthClient.constructor = FusionAuthClient;
//noinspection JSUnusedGlobalSymbols
FusionAuthClient.prototype = {

  setTenantId: function(tenantId) {
    this.tenantId = tenantId;
    return this;
  },

  /**
   * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the action is called the
   * "actioner". Both user ids are required. You pass the actionee's user id into the method and the actioner's is put into the
   * request object.
   *
   * @param {string} actioneeUserId The actionee's user id.
   * @param {ActionRequest} request The action request that includes all of the information about the action being taken including
   *    the id of the action, any options and the duration (if applicable).
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  actionUser: function(actioneeUserId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actioneeUserId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Adds a user to an existing family. The family id must be specified.
   *
   * @param {string} familyId The id of the family.
   * @param {Object} request The request object that contains all of the information used to determine which user to add to the family.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  addUserToFamily: function(familyId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family')
          .urlSegment(familyId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Cancels the user action.
   *
   * @param {string} actionId The action id of the action to cancel.
   * @param {ActionRequest} request The action request that contains the information about the cancellation.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  cancelAction: function(actionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user
   * and they clicked on a link to reset their password.
   *
   * @param {string} changePasswordId The change password Id used to find the user. This value is generated by FusionAuth once the change password workflow has been initiated.
   * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
   * @return {Promise<ClientResponse<ChangePasswordResponse>>} A Promise for the FusionAuth call.
   */
  changePassword: function(changePasswordId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/change-password')
          .urlSegment(changePasswordId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Changes a user's password using their identity (login id and password). Using a loginId instead of the changePasswordId
   * bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword
   * method.
   *
   * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  changePasswordByIdentity: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/change-password')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Adds a comment to the user's account.
   *
   * @param {UserCommentRequest} request The request object that contains all of the information used to create the user comment.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  commentOnUser: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/comment')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
   *
   * @param {?string} applicationId (Optional) The Id to use for the application. If not provided a secure random UUID will be generated.
   * @param {ApplicationRequest} request The request object that contains all of the information used to create the application.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  createApplication: function(applicationId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a new role for an application. You must specify the id of the application you are creating the role for.
   * You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
   *
   * @param {string} applicationId The Id of the application to create the role on.
   * @param {?string} roleId (Optional) The Id of the role. If not provided a secure random UUID will be generated.
   * @param {ApplicationRequest} request The request object that contains all of the information used to create the application role.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  createApplicationRole: function(applicationId, roleId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you
   * make changes to the FusionAuth database. When using the FusionAuth App web interface, any changes are automatically
   * written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
   *
   * @param {AuditLogRequest} request The request object that contains all of the information used to create the audit log entry.
   * @return {Promise<ClientResponse<AuditLogResponse>>} A Promise for the FusionAuth call.
   */
  createAuditLog: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
   *
   * @param {?string} consentId (Optional) The Id for the consent. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the consent.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createConsent: function(consentId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/consent')
          .urlSegment(consentId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
   *
   * @param {?string} emailTemplateId (Optional) The Id for the template. If not provided a secure random UUID will be generated.
   * @param {EmailTemplateRequest} request The request object that contains all of the information used to create the email template.
   * @return {Promise<ClientResponse<EmailTemplateResponse>>} A Promise for the FusionAuth call.
   */
  createEmailTemplate: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a family with the user id in the request as the owner and sole member of the family. You can optionally specify an id for the
   * family, if not provided one will be generated.
   *
   * @param {?string} familyId (Optional) The id for the family. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the family.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createFamily: function(familyId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family')
          .urlSegment(familyId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
   *
   * @param {?string} groupId (Optional) The Id for the group. If not provided a secure random UUID will be generated.
   * @param {GroupRequest} request The request object that contains all of the information used to create the group.
   * @return {Promise<ClientResponse<GroupResponse>>} A Promise for the FusionAuth call.
   */
  createGroup: function(groupId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a member in a group.
   *
   * @param {MemberRequest} request The request object that contains all of the information used to create the group member(s).
   * @return {Promise<ClientResponse<MemberResponse>>} A Promise for the FusionAuth call.
   */
  createGroupMembers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group/member')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
   *
   * @param {?string} identityProviderId (Optional) The Id of the identity provider. If not provided a secure random UUID will be generated.
   * @param {IdentityProviderRequest} request The request object that contains all of the information used to create the identity provider.
   * @return {Promise<ClientResponse<IdentityProviderResponse>>} A Promise for the FusionAuth call.
   */
  createIdentityProvider: function(identityProviderId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
   *
   * @param {?string} lambdaId (Optional) The Id for the lambda. If not provided a secure random UUID will be generated.
   * @param {LambdaRequest} request The request object that contains all of the information used to create the lambda.
   * @return {Promise<ClientResponse<LambdaResponse>>} A Promise for the FusionAuth call.
   */
  createLambda: function(lambdaId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .urlSegment(lambdaId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
   *
   * @param {?string} tenantId (Optional) The Id for the tenant. If not provided a secure random UUID will be generated.
   * @param {TenantRequest} request The request object that contains all of the information used to create the tenant.
   * @return {Promise<ClientResponse<TenantResponse>>} A Promise for the FusionAuth call.
   */
  createTenant: function(tenantId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
   *
   * @param {?string} userId (Optional) The Id for the user. If not provided a secure random UUID will be generated.
   * @param {UserRequest} request The request object that contains all of the information used to create the user.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  createUser: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after
   * that the user action can be applied to any user.
   *
   * @param {?string} userActionId (Optional) The Id for the user action. If not provided a secure random UUID will be generated.
   * @param {UserActionRequest} request The request object that contains all of the information used to create the user action.
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  createUserAction: function(userActionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user reason. This user action reason cannot be used when actioning a user until this call completes
   * successfully. Anytime after that the user action reason can be used.
   *
   * @param {?string} userActionReasonId (Optional) The Id for the user action reason. If not provided a secure random UUID will be generated.
   * @param {UserActionReasonRequest} request The request object that contains all of the information used to create the user action reason.
   * @return {Promise<ClientResponse<UserActionReasonResponse>>} A Promise for the FusionAuth call.
   */
  createUserActionReason: function(userActionReasonId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a single User consent.
   *
   * @param {?string} userConsentId (Optional) The Id for the User consent. If not provided a secure random UUID will be generated.
   * @param {Object} request The request that contains the user consent information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createUserConsent: function(userConsentId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/consent')
          .urlSegment(userConsentId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
   *
   * @param {?string} webhookId (Optional) The Id for the webhook. If not provided a secure random UUID will be generated.
   * @param {WebhookRequest} request The request object that contains all of the information used to create the webhook.
   * @return {Promise<ClientResponse<WebhookResponse>>} A Promise for the FusionAuth call.
   */
  createWebhook: function(webhookId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deactivateApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to deactivate.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deactivateUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to deactivate.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deactivateUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the users with the given ids.
   *
   * @param {Array<string>} userIds The ids of the users to deactivate.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deactivateUsers: function(userIds) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/bulk')
          .urlParameter('userId', userIds)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will
   * delete the application, any registrations for that application, metrics and reports for the application, all the
   * roles for the application, and any other data associated with the application. This operation could take a very
   * long time, depending on the amount of data in your database.
   *
   * @param {string} applicationId The Id of the application to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This
   * permanently removes the given role from all users that had it.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @param {string} roleId The Id of the role to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteApplicationRole: function(applicationId, roleId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the consent for the given Id.
   *
   * @param {string} consentId The Id of the consent to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteConsent: function(consentId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/consent')
          .urlSegment(consentId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the email template for the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteEmailTemplate: function(emailTemplateId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the group for the given Id.
   *
   * @param {string} groupId The Id of the group to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteGroup: function(groupId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Removes users as members of a group.
   *
   * @param {MemberDeleteRequest} request The member request that contains all of the information used to remove members to the group.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteGroupMembers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group/member')
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the identity provider for the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteIdentityProvider: function(identityProviderId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the key for the given Id.
   *
   * @param {string} keyOd The Id of the key to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteKey: function(keyOd) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key')
          .urlSegment(keyOd)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the lambda for the given Id.
   *
   * @param {string} lambdaId The Id of the lambda to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteLambda: function(lambdaId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .urlSegment(lambdaId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user registration for the given user and application.
   *
   * @param {string} userId The Id of the user whose registration is being deleted.
   * @param {string} applicationId The Id of the application to remove the registration for.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteRegistration: function(userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteTenant: function(tenantId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated
   * with the user.
   *
   * @param {string} userId The Id of the user to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of
   * the action being applied to any users.
   *
   * @param {string} userActionId The Id of the user action to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user action reason for the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteUserActionReason: function(userActionReasonId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the users with the given ids.
   *
   * @param {UserDeleteRequest} request The ids of the users to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteUsers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/bulk')
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the webhook for the given Id.
   *
   * @param {string} webhookId The Id of the webhook to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  deleteWebhook: function(webhookId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Disable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the User for which you're disabling Two Factor authentication.
   * @param {string} code The Two Factor code used verify the the caller knows the Two Factor secret.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  disableTwoFactor: function(userId, code) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/two-factor')
          .urlParameter('userId', userId)
          .urlParameter('code', code)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Enable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the user to enable Two Factor authentication.
   * @param {TwoFactorRequest} request The two factor enable request information.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  enableTwoFactor: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/two-factor')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Exchange a refresh token for a new JWT.
   *
   * @param {RefreshRequest} request The refresh request.
   * @return {Promise<ClientResponse<RefreshResponse>>} A Promise for the FusionAuth call.
   */
  exchangeRefreshTokenForJWT: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
   *
   * @param {ForgotPasswordRequest} request The request that contains the information about the user so that they can be emailed.
   * @return {Promise<ClientResponse<ForgotPasswordResponse>>} A Promise for the FusionAuth call.
   */
  forgotPassword: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/forgot-password')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @return {Promise<ClientResponse<VerifyEmailResponse>>} A Promise for the FusionAuth call.
   */
  generateEmailVerificationId: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlParameter('email', email)
          .urlParameter('sendVerifyPasswordEmail', false)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a new RSA or EC key pair or an HMAC secret.
   *
   * @param {?string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param {KeyRequest} request The request object that contains all of the information used to create the key.
   * @return {Promise<ClientResponse<KeyResponse>>} A Promise for the FusionAuth call.
   */
  generateKey: function(keyId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key/generate')
          .urlSegment(keyId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @return {Promise<ClientResponse<VerifyRegistrationResponse>>} A Promise for the FusionAuth call.
   */
  generateRegistrationVerificationId: function(email, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlParameter('email', email)
          .urlParameter('sendVerifyPasswordEmail', false)
          .urlParameter('applicationId', applicationId)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @return {Promise<ClientResponse<SecretResponse>>} A Promise for the FusionAuth call.
   */
  generateTwoFactorSecret: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/secret')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise<ClientResponse<SecretResponse>>} A Promise for the FusionAuth call.
   */
  generateTwoFactorSecretUsingJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/secret')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Handles login via third-parties including Social login, external OAuth and OpenID Connect, and other
   * login systems.
   *
   * @param {IdentityProviderLoginRequest} request The third-party login request that contains information from the third-party login
   *    providers that FusionAuth uses to reconcile the user's account.
   * @return {Promise<ClientResponse<LoginResponse>>} A Promise for the FusionAuth call.
   */
  identityProviderLogin: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Import an existing RSA or EC key pair or an HMAC secret.
   *
   * @param {?string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param {KeyRequest} request The request object that contains all of the information used to create the key.
   * @return {Promise<ClientResponse<KeyResponse>>} A Promise for the FusionAuth call.
   */
  importKey: function(keyId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key/import')
          .urlSegment(keyId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Bulk imports multiple users. This does some validation, but then tries to run batch inserts of users. This reduces
   * latency when inserting lots of users. Therefore, the error response might contain some information about failures,
   * but it will likely be pretty generic.
   *
   * @param {ImportRequest} request The request that contains all of the information about all of the users to import.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  importUsers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/import')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid
   * access token is properly signed and not expired.
   * <p>
   * This API may be used in an SSO configuration to issue new tokens for another application after the user has
   * obtained a valid token from authentication.
   *
   * @param {string} applicationId The Application Id for which you are requesting a new access token be issued.
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise<ClientResponse<IssueResponse>>} A Promise for the FusionAuth call.
   */
  issueJWT: function(applicationId, encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/issue')
          .authorization('JWT ' + encodedJWT)
          .urlParameter('applicationId', applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Logs a user in.
   *
   * @param {LoginRequest} request The login request that contains the user credentials used to log them in.
   * @return {Promise<ClientResponse<LoginResponse>>} A Promise for the FusionAuth call.
   */
  login: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using
   * FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an
   * application where they no longer have a session. This helps correctly track login counts, times and helps with
   * reporting.
   *
   * @param {string} userId The Id of the user that was logged in.
   * @param {string} applicationId The Id of the application that they logged into.
   * @param {?string} callerIPAddress (Optional) The IP address of the end-user that is logging in. If a null value is provided
   *    the IP address will be that of the client or last proxy that sent the request.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  loginPing: function(userId, applicationId, callerIPAddress) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/login')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .urlParameter('ipAddress', callerIPAddress)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the
   * client and revoke the refresh token stored. This API does nothing if the request does not contain an access
   * token or refresh token cookies.
   *
   * @param {boolean} global When this value is set to true all of the refresh tokens issued to the owner of the
   *    provided token will be revoked.
   * @param {?string} refreshToken (Optional) The refresh_token as a request parameter instead of coming in via a cookie.
   *    If provided this takes precedence over the cookie.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  logout: function(global, refreshToken) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/logout')
          .urlParameter('global', global)
          .urlParameter('refreshToken', refreshToken)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed
   * by a registered identity provider. A 404 indicates the domain is not managed.
   *
   * @param {string} domain The domain or email address to lookup.
   * @return {Promise<ClientResponse<LookupResponse>>} A Promise for the FusionAuth call.
   */
  lookupIdentityProvider: function(domain) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider/lookup')
          .urlParameter('domain', domain)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the
   * action.
   *
   * @param {string} actionId The Id of the action to modify. This is technically the user action log id.
   * @param {ActionRequest} request The request that contains all of the information about the modification.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  modifyAction: function(actionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Complete a login request using a passwordless code
   *
   * @param {PasswordlessLoginRequest} request The passwordless login request that contains all of the information used to complete login.
   * @return {Promise<ClientResponse<LoginResponse>>} A Promise for the FusionAuth call.
   */
  passwordlessLogin: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/passwordless/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to reactivate.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  reactivateApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to reactivate.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  reactivateUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to reactivate.
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  reactivateUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
   *
   * @param {IdentityProviderLoginRequest} request The reconcile request that contains the data to reconcile the User.
   * @return {Promise<ClientResponse<LoginResponse>>} A Promise for the FusionAuth call.
   */
  reconcileJWT: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/reconcile')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Registers a user for an application. If you provide the User and the UserRegistration object on this request, it
   * will create the user as well as register them for the application. This is called a Full Registration. However, if
   * you only provide the UserRegistration object, then the user must already exist and they will be registered for the
   * application. The user id can also be provided and it will either be used to look up an existing user or it will be
   * used for the newly created User.
   *
   * @param {?string} userId (Optional) The Id of the user being registered for the application and optionally created.
   * @param {RegistrationRequest} request The request that optionally contains the User and must contain the UserRegistration.
   * @return {Promise<ClientResponse<RegistrationResponse>>} A Promise for the FusionAuth call.
   */
  register: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Removes a user from the family with the given id.
   *
   * @param {string} familyId The id of the family to remove the user from.
   * @param {string} userId The id of the user to remove from the family.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  removeUserFromFamily: function(familyId, userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family')
          .urlSegment(familyId)
          .urlSegment(userId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Re-sends the verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @return {Promise<ClientResponse<VerifyEmailResponse>>} A Promise for the FusionAuth call.
   */
  resendEmailVerification: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlParameter('email', email)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Re-sends the application registration verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @return {Promise<ClientResponse<VerifyRegistrationResponse>>} A Promise for the FusionAuth call.
   */
  resendRegistrationVerification: function(email, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlParameter('email', email)
          .urlParameter('applicationId', applicationId)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
   *
   * @param {string} actionId The Id of the action to retrieve.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveAction: function(actionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the actions for the user with the given Id. This will return all time based actions that are active,
   * and inactive as well as non-time based actions.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveActions: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the actions for the user with the given Id that are currently preventing the User from logging in.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveActionsPreventingLogin: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlParameter('userId', userId)
          .urlParameter('preventingLogin', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the actions for the user with the given Id that are currently active.
   * An active action means one that is time based and has not been canceled, and has not ended.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveActiveActions: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlParameter('userId', userId)
          .urlParameter('active', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the application for the given id or all of the applications if the id is null.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the applications.
   *
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveApplications: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves a single audit log for the given Id.
   *
   * @param {number} auditLogId The Id of the audit log to retrieve.
   * @return {Promise<ClientResponse<AuditLogResponse>>} A Promise for the FusionAuth call.
   */
  retrieveAuditLog: function(auditLogId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log')
          .urlSegment(auditLogId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the Consent for the given Id.
   *
   * @param {string} consentId The Id of the consent.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveConsent: function(consentId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/consent')
          .urlSegment(consentId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the consent.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveConsents: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/consent')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the daily active user report between the two instants. If you specify an application id, it will only
   * return the daily active counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<DailyActiveUserReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveDailyActiveReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/daily-active-user')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the email template for the given Id. If you don't specify the id, this will return all of the email templates.
   *
   * @param {?string} emailTemplateId (Optional) The Id of the email template.
   * @return {Promise<ClientResponse<EmailTemplateResponse>>} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplate: function(emailTemplateId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a preview of the email template provided in the request. This allows you to preview an email template that
   * hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This
   * will create the preview based on whatever is given.
   *
   * @param {PreviewRequest} request The request that contains the email template and optionally a locale to render it in.
   * @return {Promise<ClientResponse<PreviewResponse>>} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplatePreview: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template/preview')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the email templates.
   *
   * @return {Promise<ClientResponse<EmailTemplateResponse>>} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplates: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves a single event log for the given Id.
   *
   * @param {number} eventLogId The Id of the event log to retrieve.
   * @return {Promise<ClientResponse<EventLogResponse>>} A Promise for the FusionAuth call.
   */
  retrieveEventLog: function(eventLogId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/event-log')
          .urlSegment(eventLogId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the families that a user belongs to.
   *
   * @param {string} userId The User's id
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveFamilies: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the members of a family by the unique Family Id.
   *
   * @param {string} familyId The unique Id of the Family.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveFamilyMembersByFamilyId: function(familyId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family')
          .urlSegment(familyId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the group for the given Id.
   *
   * @param {string} groupId The Id of the group.
   * @return {Promise<ClientResponse<GroupResponse>>} A Promise for the FusionAuth call.
   */
  retrieveGroup: function(groupId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the groups.
   *
   * @return {Promise<ClientResponse<GroupResponse>>} A Promise for the FusionAuth call.
   */
  retrieveGroups: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the identity provider for the given id or all of the identity providers if the id is null.
   *
   * @param {?string} identityProviderId (Optional) The identity provider id.
   * @return {Promise<ClientResponse<IdentityProviderResponse>>} A Promise for the FusionAuth call.
   */
  retrieveIdentityProvider: function(identityProviderId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the identity providers.
   *
   * @return {Promise<ClientResponse<IdentityProviderResponse>>} A Promise for the FusionAuth call.
   */
  retrieveIdentityProviders: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the actions for the user with the given Id that are currently inactive.
   * An inactive action means one that is time based and has been canceled or has expired, or is not time based.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @return {Promise<ClientResponse<ActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveInactiveActions: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlParameter('userId', userId)
          .urlParameter('active', false)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the applications that are currently inactive.
   *
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveInactiveApplications: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlParameter('inactive', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the user actions that are currently inactive.
   *
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveInactiveUserActions: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlParameter('inactive', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the available integrations.
   *
   * @return {Promise<ClientResponse<IntegrationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveIntegration: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/integration')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id. If the key Id is provided a
   * single public key will be returned if one is found by that id. If the optional parameter key Id is not provided all
   * public keys will be returned.
   *
   * @param {?string} keyId (Optional) The Id of the public key.
   * @return {Promise<ClientResponse<PublicKeyResponse>>} A Promise for the FusionAuth call.
   */
  retrieveJWTPublicKey: function(keyId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/public-key')
          .urlSegment(keyId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all Public Keys configured for verifying JSON Web Tokens (JWT).
   *
   * @return {Promise<ClientResponse<PublicKeyResponse>>} A Promise for the FusionAuth call.
   */
  retrieveJWTPublicKeys: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/public-key')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the key for the given Id.
   *
   * @param {string} keyId The Id of the key.
   * @return {Promise<ClientResponse<KeyResponse>>} A Promise for the FusionAuth call.
   */
  retrieveKey: function(keyId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key')
          .urlSegment(keyId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the keys.
   *
   * @return {Promise<ClientResponse<KeyResponse>>} A Promise for the FusionAuth call.
   */
  retrieveKeys: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the lambda for the given Id.
   *
   * @param {string} lambdaId The Id of the lambda.
   * @return {Promise<ClientResponse<LambdaResponse>>} A Promise for the FusionAuth call.
   */
  retrieveLambda: function(lambdaId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .urlSegment(lambdaId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the lambdas.
   *
   * @return {Promise<ClientResponse<LambdaResponse>>} A Promise for the FusionAuth call.
   */
  retrieveLambdas: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the lambdas for the provided type.
   *
   * @param {LambdaType} type The type of the lambda to return.
   * @return {Promise<ClientResponse<LambdaResponse>>} A Promise for the FusionAuth call.
   */
  retrieveLambdasByType: function(type) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .urlParameter('type', type)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the login report between the two instants. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<LoginReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveLoginReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/login')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the monthly active user report between the two instants. If you specify an application id, it will only
   * return the monthly active counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<MonthlyActiveUserReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveMonthlyActiveReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/monthly-active-user')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the Oauth2 configuration for the application for the given Application Id.
   *
   * @param {string} applicationId The Id of the Application to retrieve OAuth configuration.
   * @return {Promise<ClientResponse<OAuthConfigurationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveOauthConfiguration: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("oauth-configuration")
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the password validation rules.
   *
   * @return {Promise<ClientResponse<PasswordValidationRulesResponse>>} A Promise for the FusionAuth call.
   */
  retrievePasswordValidationRules: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration/password-validation-rules')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the children for the given parent email address.
   *
   * @param {string} parentEmail The email of the parent.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrievePendingChildren: function(parentEmail) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family/pending')
          .urlParameter('parentEmail', parentEmail)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the last number of login records.
   *
   * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
   * @return {Promise<ClientResponse<RecentLoginResponse>>} A Promise for the FusionAuth call.
   */
  retrieveRecentLogins: function(offset, limit) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/recent-login')
          .urlParameter('offset', offset)
          .urlParameter('limit', limit)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the refresh tokens that belong to the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise<ClientResponse<RefreshResponse>>} A Promise for the FusionAuth call.
   */
  retrieveRefreshTokens: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user registration for the user with the given id and the given application id.
   *
   * @param {string} userId The Id of the user.
   * @param {string} applicationId The Id of the application.
   * @return {Promise<ClientResponse<RegistrationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveRegistration: function(userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the registration report between the two instants. If you specify an application id, it will only return
   * the registration counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<RegistrationReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveRegistrationReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/registration')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the system configuration.
   *
   * @return {Promise<ClientResponse<SystemConfigurationResponse>>} A Promise for the FusionAuth call.
   */
  retrieveSystemConfiguration: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant.
   * @return {Promise<ClientResponse<TenantResponse>>} A Promise for the FusionAuth call.
   */
  retrieveTenant: function(tenantId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the tenants.
   *
   * @return {Promise<ClientResponse<TenantResponse>>} A Promise for the FusionAuth call.
   */
  retrieveTenants: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the totals report. This contains all of the total counts for each application and the global registration
   * count.
   *
   * @return {Promise<ClientResponse<TotalsReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveTotalReport: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/totals')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user action for the given Id. If you pass in null for the id, this will return all of the user
   * actions.
   *
   * @param {?string} userActionId (Optional) The Id of the user action.
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user action reason for the given Id. If you pass in null for the id, this will return all of the user
   * action reasons.
   *
   * @param {?string} userActionReasonId (Optional) The Id of the user action reason.
   * @return {Promise<ClientResponse<UserActionReasonResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserActionReason: function(userActionReasonId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all the user action reasons.
   *
   * @return {Promise<ClientResponse<UserActionReasonResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserActionReasons: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the user actions.
   *
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserActions: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} changePasswordId The unique change password Id that was sent via email or returned by the Forgot Password API.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserByChangePasswordId: function(changePasswordId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('changePasswordId', changePasswordId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given email.
   *
   * @param {string} email The email of the user.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserByEmail: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('email', email)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the loginId. The loginId can be either the username or the email.
   *
   * @param {string} loginId The email or username of the user.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserByLoginId: function(loginId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('loginId', loginId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given username.
   *
   * @param {string} username The username of the user.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserByUsername: function(username) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('username', username)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} verificationId The unique verification Id that has been set on the user object.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserByVerificationId: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('verificationId', verificationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the comments for the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise<ClientResponse<UserCommentResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserComments: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/comment')
          .urlSegment(userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieve a single User consent by Id.
   *
   * @param {string} userConsentId The User consent Id
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserConsent: function(userConsentId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/consent')
          .urlSegment(userConsentId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the consents for a User.
   *
   * @param {string} userId The User's Id
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserConsents: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/consent')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the login report between the two instants for a particular user by Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {string} userId The userId id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<LoginReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserLoginReport: function(applicationId, userId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/login')
          .urlParameter('applicationId', applicationId)
          .urlParameter('userId', userId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the login report between the two instants for a particular user by login Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {string} loginId The userId id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise<ClientResponse<LoginReportResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserLoginReportByLoginId: function(applicationId, loginId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/login')
          .urlParameter('applicationId', applicationId)
          .urlParameter('loginId', loginId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the last number of login records for a user.
   *
   * @param {string} userId The Id of the user.
   * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
   * @return {Promise<ClientResponse<RecentLoginResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserRecentLogins: function(userId, offset, limit) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/recent-login')
          .urlParameter('userId', userId)
          .urlParameter('offset', offset)
          .urlParameter('limit', limit)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  retrieveUserUsingJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the webhook for the given Id. If you pass in null for the id, this will return all the webhooks.
   *
   * @param {?string} webhookId (Optional) The Id of the webhook.
   * @return {Promise<ClientResponse<WebhookResponse>>} A Promise for the FusionAuth call.
   */
  retrieveWebhook: function(webhookId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all the webhooks.
   *
   * @return {Promise<ClientResponse<WebhookResponse>>} A Promise for the FusionAuth call.
   */
  retrieveWebhooks: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Revokes a single refresh token, all tokens for a user or all tokens for an application. If you provide a user id
   * and an application id, this will delete all the refresh tokens for that user for that application.
   *
   * @param {?string} token (Optional) The refresh token to delete.
   * @param {?string} userId (Optional) The user id whose tokens to delete.
   * @param {?string} applicationId (Optional) The application id of the tokens to delete.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  revokeRefreshToken: function(token, userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .urlParameter('token', token)
          .urlParameter('userId', userId)
          .urlParameter('applicationId', applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Revokes a single User consent by Id.
   *
   * @param {string} userConsentId The User Consent Id
   * @return {Promise} A Promise for the FusionAuth call.
   */
  revokeUserConsent: function(userConsentId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/consent')
          .urlSegment(userConsentId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Searches the audit logs with the specified criteria and pagination.
   *
   * @param {AuditLogSearchRequest} request The search criteria and pagination information.
   * @return {Promise<ClientResponse<AuditLogSearchResponse>>} A Promise for the FusionAuth call.
   */
  searchAuditLogs: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Searches the event logs with the specified criteria and pagination.
   *
   * @param {EventLogSearchRequest} request The search criteria and pagination information.
   * @return {Promise<ClientResponse<EventLogSearchResponse>>} A Promise for the FusionAuth call.
   */
  searchEventLogs: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/event-log/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Searches the login records with the specified criteria and pagination.
   *
   * @param {Object} request The search criteria and pagination information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  searchLoginRecords: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/login-record/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the users for the given ids. If any id is invalid, it is ignored.
   *
   * @param {Array<string>} ids The user ids to search for.
   * @return {Promise<ClientResponse<SearchResponse>>} A Promise for the FusionAuth call.
   */
  searchUsers: function(ids) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/search')
          .urlParameter('ids', ids)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the users for the given search criteria and pagination.
   *
   * @param {SearchRequest} request The search criteria and pagination constraints. Fields used: queryString, numberOfResults, startRow,
   *    and sort fields.
   * @return {Promise<ClientResponse<SearchResponse>>} A Promise for the FusionAuth call.
   */
  searchUsersByQueryString: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send an email using an email template id. You can optionally provide <code>requestData</code> to access key value
   * pairs in the email template.
   *
   * @param {string} emailTemplateId The id for the template.
   * @param {SendRequest} request The send email request that contains all of the information used to send the email.
   * @return {Promise<ClientResponse<SendResponse>>} A Promise for the FusionAuth call.
   */
  sendEmail: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/send')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Sends out an email to a parent that they need to register and create a family or need to log in and add a child to their existing family.
   *
   * @param {Object} request The request object that contains the parent email.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  sendFamilyRequestEmail: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/family/request')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send a passwordless authentication code in an email to complete login.
   *
   * @param {PasswordlessSendRequest} request The passwordless send request that contains all of the information used to send an email containing a code.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  sendPasswordlessCode: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/passwordless/send')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
   *
   * @param {TwoFactorSendRequest} request The request object that contains all of the information used to send the code.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  sendTwoFactorCode: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/send')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send a Two Factor authentication code to allow the completion of Two Factor authentication.
   *
   * @param {string} twoFactorId The Id returned by the Login API necessary to complete Two Factor authentication.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  sendTwoFactorCodeForLogin: function(twoFactorId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/send')
          .urlSegment(twoFactorId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Complete login using a 2FA challenge
   *
   * @param {TwoFactorLoginRequest} request The login request that contains the user credentials used to log them in.
   * @return {Promise<ClientResponse<LoginResponse>>} A Promise for the FusionAuth call.
   */
  twoFactorLogin: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to update.
   * @param {ApplicationRequest} request The request that contains all of the new application information.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  updateApplication: function(applicationId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the application role with the given id for the application.
   *
   * @param {string} applicationId The Id of the application that the role belongs to.
   * @param {string} roleId The Id of the role to update.
   * @param {ApplicationRequest} request The request that contains all of the new role information.
   * @return {Promise<ClientResponse<ApplicationResponse>>} A Promise for the FusionAuth call.
   */
  updateApplicationRole: function(applicationId, roleId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the consent with the given Id.
   *
   * @param {string} consentId The Id of the consent to update.
   * @param {Object} request The request that contains all of the new consent information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateConsent: function(consentId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/consent')
          .urlSegment(consentId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the email template with the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to update.
   * @param {EmailTemplateRequest} request The request that contains all of the new email template information.
   * @return {Promise<ClientResponse<EmailTemplateResponse>>} A Promise for the FusionAuth call.
   */
  updateEmailTemplate: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the group with the given Id.
   *
   * @param {string} groupId The Id of the group to update.
   * @param {GroupRequest} request The request that contains all of the new group information.
   * @return {Promise<ClientResponse<GroupResponse>>} A Promise for the FusionAuth call.
   */
  updateGroup: function(groupId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the identity provider with the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to update.
   * @param {IdentityProviderRequest} request The request object that contains the updated identity provider.
   * @return {Promise<ClientResponse<IdentityProviderResponse>>} A Promise for the FusionAuth call.
   */
  updateIdentityProvider: function(identityProviderId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the available integrations.
   *
   * @param {IntegrationRequest} request The request that contains all of the new integration information.
   * @return {Promise<ClientResponse<IntegrationResponse>>} A Promise for the FusionAuth call.
   */
  updateIntegrations: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/integration')
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the key with the given Id.
   *
   * @param {string} keyId The Id of the key to update.
   * @param {KeyRequest} request The request that contains all of the new key information.
   * @return {Promise<ClientResponse<KeyResponse>>} A Promise for the FusionAuth call.
   */
  updateKey: function(keyId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/key')
          .urlSegment(keyId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the lambda with the given Id.
   *
   * @param {string} lambdaId The Id of the lambda to update.
   * @param {LambdaRequest} request The request that contains all of the new lambda information.
   * @return {Promise<ClientResponse<LambdaResponse>>} A Promise for the FusionAuth call.
   */
  updateLambda: function(lambdaId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/lambda')
          .urlSegment(lambdaId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the registration for the user with the given id and the application defined in the request.
   *
   * @param {string} userId The Id of the user whose registration is going to be updated.
   * @param {RegistrationRequest} request The request that contains all of the new registration information.
   * @return {Promise<ClientResponse<RegistrationResponse>>} A Promise for the FusionAuth call.
   */
  updateRegistration: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the system configuration.
   *
   * @param {SystemConfigurationRequest} request The request that contains all of the new system configuration information.
   * @return {Promise<ClientResponse<SystemConfigurationResponse>>} A Promise for the FusionAuth call.
   */
  updateSystemConfiguration: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration')
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the tenant with the given Id.
   *
   * @param {string} tenantId The Id of the tenant to update.
   * @param {TenantRequest} request The request that contains all of the new tenant information.
   * @return {Promise<ClientResponse<TenantResponse>>} A Promise for the FusionAuth call.
   */
  updateTenant: function(tenantId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user with the given Id.
   *
   * @param {string} userId The Id of the user to update.
   * @param {UserRequest} request The request that contains all of the new user information.
   * @return {Promise<ClientResponse<UserResponse>>} A Promise for the FusionAuth call.
   */
  updateUser: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to update.
   * @param {UserActionRequest} request The request that contains all of the new user action information.
   * @return {Promise<ClientResponse<UserActionResponse>>} A Promise for the FusionAuth call.
   */
  updateUserAction: function(userActionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user action reason with the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to update.
   * @param {UserActionReasonRequest} request The request that contains all of the new user action reason information.
   * @return {Promise<ClientResponse<UserActionReasonResponse>>} A Promise for the FusionAuth call.
   */
  updateUserActionReason: function(userActionReasonId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates a single User consent by Id.
   *
   * @param {string} userConsentId The User Consent Id
   * @param {Object} request The request that contains the user consent information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateUserConsent: function(userConsentId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/consent')
          .urlSegment(userConsentId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the webhook with the given Id.
   *
   * @param {string} webhookId The Id of the webhook to update.
   * @param {WebhookRequest} request The request that contains all of the new webhook information.
   * @return {Promise<ClientResponse<WebhookResponse>>} A Promise for the FusionAuth call.
   */
  updateWebhook: function(webhookId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly
   * signed and not expired.
   * <p>
   * This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise<ClientResponse<ValidateResponse>>} A Promise for the FusionAuth call.
   */
  validateJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/validate')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Confirms a email verification. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The email verification id sent to the user.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  verifyEmail: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlSegment(verificationId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Confirms an application registration. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The registration verification Id sent to the user.
   * @return {Promise<ClientResponse<void>>} A Promise for the FusionAuth call.
   */
  verifyRegistration: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlSegment(verificationId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /* ===================================================================================================================
   * Private methods
   * ===================================================================================================================*/

  /**
   * Require a parameter to be defined, if null or un-defined this throws an exception.
   * @param {Object} value The value that must be defined.
   * @param {string} name The name of the parameter.
   * @private
   */
  _requireNonNull: function(value, name) {
    if (typeof value === 'undefined' || value === null) {
      throw new Error(name + ' parameter is required.');
    }
  },

  /**
   * Returns a function to handle the promises for each call.
   *
   * @param {Function} resolve The promise's resolve function.
   * @param {Function} reject The promise's reject function.
   * @returns {Function} The function that will call either the resolve or reject functions based on the ClientResponse.
   * @private
   */
  _responseHandler: function(resolve, reject) {
    return function(response) {
      if (response.wasSuccessful()) {
        resolve(response);
      } else {
        reject(response);
      }
    };
  },

  /**
   * creates a rest client
   *
   * @returns {RESTClient} The RESTClient that will be used to call.
   * @private
   */
  _start: function() {
    const client = new RESTClient().authorization(this.apiKey).setUrl(this.host);

    if (this.tenantId !== null && typeof(this.tenantId) !== 'undefined') {
      client.header('X-FusionAuth-TenantId', this.tenantId);
    }

    return client;
  }
};

/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} AccessToken
 *
 * @property {string} [access_token]
 * @property {string} [clientId]
 * @property {number} [expires_in]
 * @property {string} [id_token]
 * @property {string} [redirectURI]
 * @property {string} [refresh_token]
 * @property {string} [scope]
 * @property {TokenType} [token_type]
 * @property {string} [userId]
 */


/**
 * @typedef {Object} ActionData
 *
 * @property {UserAction} [action]
 * @property {User} [actionee]
 * @property {string} [actioneeUserId]
 * @property {User} [actioner]
 * @property {string} [actionerUserId]
 * @property {Array<string>} [applicationIds]
 * @property {string} [comment]
 * @property {boolean} [emailUser]
 * @property {number} [expiry]
 * @property {UserActionLog} [log]
 * @property {boolean} [notifyUser]
 * @property {string} [option]
 * @property {UserActionReason} [reason]
 * @property {string} [reasonId]
 * @property {string} [userActionId]
 */


/**
 * The user action request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ActionRequest
 *
 * @property {ActionData} [action]
 * @property {boolean} [broadcast]
 */


/**
 * The user action response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ActionResponse
 *
 * @property {UserActionLog} [action]
 * @property {Array<UserActionLog>} [actions]
 */


/**
 * Available JSON Web Algorithms (JWA) as described in RFC 7518 available for this JWT implementation.
 *
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var Algorithm = {
  ES256: "ES256",
  ES384: "ES384",
  ES512: "ES512",
  HS256: "HS256",
  HS384: "HS384",
  HS512: "HS512",
  RS256: "RS256",
  RS384: "RS384",
  RS512: "RS512",
  none: "none"
};

/**
 * @author Seth Musselman
 *
 * @typedef {Object} Application
 *
 * @property {boolean} [active]
 * @property {AuthenticationTokenConfiguration} [authenticationTokenConfiguration]
 * @property {CleanSpeakConfiguration} [cleanSpeakConfiguration]
 * @property {Object<string, Object>} [data]
 * @property {string} [id]
 * @property {JWTConfiguration} [jwtConfiguration]
 * @property {LambdaConfiguration} [lambdaConfiguration]
 * @property {LoginConfiguration} [loginConfiguration]
 * @property {string} [name]
 * @property {OAuth2Configuration} [oauthConfiguration]
 * @property {PasswordlessConfiguration} [passwordlessConfiguration]
 * @property {RegistrationConfiguration} [registrationConfiguration]
 * @property {Array<ApplicationRole>} [roles]
 * @property {SAMLv2Configuration} [samlv2Configuration]
 * @property {string} [tenantId]
 * @property {string} [verificationEmailTemplateId]
 * @property {boolean} [verifyRegistration]
 */


/**
 * Events that are bound to applications.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ApplicationEvent
 *
 */


/**
 * The Application API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ApplicationRequest
 *
 * @property {Application} [application]
 * @property {ApplicationRole} [role]
 * @property {Array<string>} [webhookIds]
 */


/**
 * The Application API response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ApplicationResponse
 *
 * @property {Application} [application]
 * @property {Array<Application>} [applications]
 * @property {ApplicationRole} [role]
 */


/**
 * A role given to a user for a specific application.
 *
 * @author Seth Musselman
 *
 * @typedef {Object} ApplicationRole
 *
 * @property {string} [applicationId]
 * @property {string} [description]
 * @property {string} [display]
 * @property {string} [id]
 * @property {boolean} [isDefault]
 * @property {boolean} [isSuperRole]
 * @property {string} [name]
 */


/**
 * This class is a simple attachment with a byte array, name and MIME type.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Attachment
 *
 * @property {Array<number>} [attachment]
 * @property {string} [mime]
 * @property {string} [name]
 */


/**
 * An audit log.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLog
 *
 * @property {Object<string, Object>} [data]
 * @property {number} [id]
 * @property {number} [insertInstant]
 * @property {string} [insertUser]
 * @property {string} [message]
 * @property {Object} [newValue]
 * @property {Object} [oldValue]
 * @property {string} [reason]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLogRequest
 *
 * @property {AuditLog} [auditLog]
 */


/**
 * Audit log response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLogResponse
 *
 * @property {AuditLog} [auditLog]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLogSearchCriteria
 * @extends BaseSearchCriteria
 *
 * @property {number} [end]
 * @property {string} [message]
 * @property {number} [start]
 * @property {string} [user]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLogSearchRequest
 *
 * @property {AuditLogSearchCriteria} [search]
 */


/**
 * Audit log response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} AuditLogSearchResponse
 *
 * @property {Array<AuditLog>} [auditLogs]
 * @property {number} [total]
 */


/**
 * @typedef {Object} AuthenticationTokenConfiguration
 * @extends Enableable
 *
 */


/**
 * Base-class for all FusionAuth events.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} BaseEvent
 *
 * @property {number} [createInstant]
 * @property {string} [id]
 * @property {EventType} [type]
 */


/**

 *
 * @typedef {Object} BaseIdentityProvider
 * @template {D}
 * @extends Enableable
 *
 * @property {Object<string, D>} [applicationConfiguration]
 * @property {Object<string, Object>} [data]
 * @property {string} [id]
 * @property {string} [name]
 * @property {IdentityProviderType} [type]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} BaseIdentityProviderApplicationConfiguration
 * @extends Enableable
 *
 * @property {boolean} [createRegistration]
 * @property {Object<string, Object>} [data]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} BaseLoginRequest
 *
 * @property {string} [applicationId]
 * @property {string} [ipAddress]
 * @property {MetaData} [metaData]
 * @property {boolean} [noJWT]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} BaseSearchCriteria
 *
 * @property {number} [numberOfResults]
 * @property {string} [orderBy]
 * @property {number} [startRow]
 */


/**
 * @readonly
 * @enum
 */
var CanonicalizationMethod = {
  exclusive: "exclusive",
  exclusive_with_comments: "exclusive_with_comments",
  inclusive: "inclusive",
  inclusive_with_comments: "inclusive_with_comments"
};

/**
 * @typedef {Object} CertificateInformation
 *
 * @property {string} [issuer]
 * @property {string} [md5Fingerprint]
 * @property {string} [serialNumber]
 * @property {string} [sha1Fingerprint]
 * @property {string} [sha1Thumbprint]
 * @property {string} [sha256Fingerprint]
 * @property {string} [sha256Thumbprint]
 * @property {string} [subject]
 * @property {number} [validFrom]
 * @property {number} [validTo]
 */


/**
 * Change password request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ChangePasswordRequest
 *
 * @property {string} [currentPassword]
 * @property {string} [loginId]
 * @property {string} [password]
 * @property {string} [refreshToken]
 */


/**
 * Change password response object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} ChangePasswordResponse
 *
 * @property {string} [oneTimePassword]
 * @property {Object<string, Object>} [state]
 */


/**
 * CleanSpeak configuration at the system and application level.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} CleanSpeakConfiguration
 * @extends Enableable
 *
 * @property {string} [apiKey]
 * @property {Array<string>} [applicationIds]
 * @property {string} [url]
 * @property {UsernameModeration} [usernameModeration]
 */


/**
 * Status for content like usernames, profile attributes, etc.
 *
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var ContentStatus = {
  ACTIVE: "ACTIVE",
  PENDING: "PENDING",
  REJECTED: "REJECTED"
};

/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} Count
 *
 * @property {number} [count]
 * @property {number} [interval]
 */


/**
 * Response for the daily active user report.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} DailyActiveUserReportResponse
 *
 * @property {Array<Count>} [dailyActiveUsers]
 * @property {number} [total]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} DeviceInfo
 *
 * @property {string} [description]
 * @property {string} [lastAccessedAddress]
 * @property {number} [lastAccessedInstant]
 * @property {string} [name]
 * @property {DeviceType} [type]
 */


/**
 * @readonly
 * @enum
 */
var DeviceType = {
  BROWSER: "BROWSER",
  DESKTOP: "DESKTOP",
  LAPTOP: "LAPTOP",
  MOBILE: "MOBILE",
  OTHER: "OTHER",
  SERVER: "SERVER",
  TABLET: "TABLET",
  TV: "TV",
  UNKNOWN: "UNKNOWN"
};

/**
 * A displayable raw login that includes application name and user loginId.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} DisplayableRawLogin
 * @extends RawLogin
 *
 * @property {string} [applicationName]
 * @property {string} [loginId]
 */


/**
 * Interface for all identity providers that can be domain based.
 *
 * @typedef {Object} DomainBasedIdentityProvider
 *
 */


/**
 * This class is an abstraction of a simple email message.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Email
 *
 * @property {Array<Attachment>} [attachments]
 * @property {Array<EmailAddress>} [bcc]
 * @property {Array<EmailAddress>} [cc]
 * @property {EmailAddress} [from]
 * @property {string} [html]
 * @property {EmailAddress} [replyTo]
 * @property {string} [subject]
 * @property {string} [text]
 * @property {Array<EmailAddress>} [to]
 */


/**
 * An email address.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EmailAddress
 *
 * @property {string} [address]
 * @property {string} [display]
 */


/**
 * @typedef {Object} EmailConfiguration
 * @extends Enableable
 *
 * @property {string} [forgotPasswordEmailTemplateId]
 * @property {string} [host]
 * @property {string} [password]
 * @property {string} [passwordlessEmailTemplateId]
 * @property {number} [port]
 * @property {string} [properties]
 * @property {EmailSecurityType} [security]
 * @property {string} [setPasswordEmailTemplateId]
 * @property {string} [username]
 * @property {string} [verificationEmailTemplateId]
 * @property {boolean} [verifyEmail]
 * @property {boolean} [verifyEmailWhenChanged]
 */


/**
 * @readonly
 * @enum
 */
var EmailSecurityType = {
  NONE: "NONE",
  SSL: "SSL",
  TLS: "TLS"
};

/**
 * Stores an email template used to send emails to users.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EmailTemplate
 *
 * @property {string} [defaultFromName]
 * @property {string} [defaultHtmlTemplate]
 * @property {string} [defaultSubject]
 * @property {string} [defaultTextTemplate]
 * @property {string} [fromEmail]
 * @property {string} [id]
 * @property {Object<string>} [localizations]
 * @property {LocalizedStrings} [localizedFromNames]
 * @property {LocalizedStrings} [localizedHtmlTemplates]
 * @property {LocalizedStrings} [localizedSubjects]
 * @property {LocalizedStrings} [localizedTextTemplates]
 * @property {string} [name]
 */


/**
 * @typedef {Object} EmailTemplateErrors
 *
 * @property {Object<string, string>} [parseErrors]
 * @property {Object<string, string>} [renderErrors]
 */


/**
 * Email template request.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EmailTemplateRequest
 *
 * @property {EmailTemplate} [emailTemplate]
 */


/**
 * Email template response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EmailTemplateResponse
 *
 * @property {EmailTemplate} [emailTemplate]
 * @property {Array<EmailTemplate>} [emailTemplates]
 */


/**
 * Something that can be enabled and thus also disabled.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} Enableable
 *
 * @property {boolean} [enabled]
 */


/**
 * Defines an error.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Error
 *
 * @property {string} [code]
 * @property {string} [message]
 * @property {Array<Object>} [values]
 */


/**
 * Standard error domain object that can also be used as the response from an API call.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Errors
 *
 * @property {Object<string, Array<Error>>} [fieldErrors]
 * @property {Array<Error>} [generalErrors]
 */


/**
 * @typedef {Object} EventConfiguration
 *
 * @property {Object<EventType, EventConfigurationData>} [events]
 */


/**
 * @typedef {Object} EventConfigurationData
 * @extends Enableable
 *
 * @property {TransactionType} [transactionType]
 */


/**
 * Event log used internally by FusionAuth to help developers debug hooks, Webhooks, email templates, etc.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EventLog
 *
 * @property {number} [id]
 * @property {number} [insertInstant]
 * @property {string} [message]
 * @property {EventLogType} [type]
 */


/**
 * @typedef {Object} EventLogConfiguration
 *
 * @property {number} [numberToRetain]
 */


/**
 * Event log response.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} EventLogResponse
 *
 * @property {EventLog} [eventLog]
 */


/**
 * Search criteria for the event log.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EventLogSearchCriteria
 * @extends BaseSearchCriteria
 *
 * @property {number} [end]
 * @property {string} [message]
 * @property {number} [start]
 * @property {EventLogType} [type]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} EventLogSearchRequest
 *
 * @property {EventLogSearchCriteria} [search]
 */


/**
 * Event log response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EventLogSearchResponse
 *
 * @property {Array<EventLog>} [eventLogs]
 * @property {number} [total]
 */


/**
 * Event Log Type
 *
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var EventLogType = {
  Information: "Information",
  Debug: "Debug",
  Error: "Error"
};

/**
 * Container for the event information. This is the JSON that is sent from FusionAuth to webhooks.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} EventRequest
 *
 * @property {BaseEvent} [event]
 */


/**
 * Models the event types that FusionAuth produces.
 *
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var EventType = {
  UserDelete: "UserDelete",
  UserCreate: "UserCreate",
  UserUpdate: "UserUpdate",
  UserDeactivate: "UserDeactivate",
  UserBulkCreate: "UserBulkCreate",
  UserReactivate: "UserReactivate",
  UserAction: "UserAction",
  JWTRefreshTokenRevoke: "JWTRefreshTokenRevoke",
  JWTPublicKeyUpdate: "JWTPublicKeyUpdate",
  UserLoginSuccess: "UserLoginSuccess",
  UserLoginFailed: "UserLoginFailed",
  UserRegistrationCreate: "UserRegistrationCreate",
  UserRegistrationUpdate: "UserRegistrationUpdate",
  UserRegistrationDelete: "UserRegistrationDelete",
  Test: "Test"
};

/**
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var ExpiryUnit = {
  MINUTES: "MINUTES",
  HOURS: "HOURS",
  DAYS: "DAYS",
  WEEKS: "WEEKS",
  MONTHS: "MONTHS",
  YEARS: "YEARS"
};

/**
 * @typedef {Object} ExternalIdentifierConfiguration
 *
 * @property {number} [authorizationGrantIdTimeToLiveInSeconds]
 * @property {number} [changePasswordIdTimeToLiveInSeconds]
 * @property {number} [emailVerificationIdTimeToLiveInSeconds]
 * @property {number} [oneTimePasswordTimeToLiveInSeconds]
 * @property {number} [passwordlessLoginTimeToLiveInSeconds]
 * @property {number} [registrationVerificationIdTimeToLiveInSeconds]
 * @property {number} [setupPasswordIdTimeToLiveInSeconds]
 * @property {number} [twoFactorIdTimeToLiveInSeconds]
 * @property {number} [twoFactorTrustIdTimeToLiveInSeconds]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} ExternalJWTApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 */


/**
 * External JWT-only identity provider.
 *
 * @author Daniel DeGroff and Brian Pontarelli
 *
 * @typedef {Object} ExternalJWTIdentityProvider
 * @extends BaseIdentityProvider<ExternalJWTApplicationConfiguration>
 *
 * @property {Object<string, string>} [claimMap]
 * @property {Object<string>} [domains]
 * @property {string} [headerKeyParameter]
 * @property {Object<string, string>} [keys]
 * @property {IdentityProviderOauth2Configuration} [oauth2]
 * @property {IdentityProviderType} [type]
 * @property {string} [uniqueIdentityClaim]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} FacebookApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [appId]
 * @property {string} [buttonText]
 * @property {string} [client_secret]
 * @property {string} [fields]
 * @property {string} [permissions]
 */


/**
 * Facebook social login provider.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} FacebookIdentityProvider
 * @extends BaseIdentityProvider<FacebookApplicationConfiguration>
 *
 * @property {string} [appId]
 * @property {string} [buttonText]
 * @property {string} [client_secret]
 * @property {string} [fields]
 * @property {string} [permissions]
 * @property {IdentityProviderType} [type]
 */


/**
 * Configuration for the behavior of failed login attempts. This helps us protect against brute force password attacks.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} FailedAuthenticationConfiguration
 *
 * @property {number} [actionDuration]
 * @property {ExpiryUnit} [actionDurationUnit]
 * @property {number} [resetCountInSeconds]
 * @property {number} [tooManyAttempts]
 * @property {string} [userActionId]
 */


/**
 * Forgot password request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ForgotPasswordRequest
 *
 * @property {string} [changePasswordId]
 * @property {string} [email]
 * @property {string} [loginId]
 * @property {boolean} [sendForgotPasswordEmail]
 * @property {Object<string, Object>} [state]
 * @property {string} [username]
 */


/**
 * Forgot password response object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} ForgotPasswordResponse
 *
 * @property {string} [changePasswordId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} GoogleApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [buttonText]
 * @property {string} [client_id]
 * @property {string} [client_secret]
 * @property {string} [scope]
 */


/**
 * Google social login provider.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} GoogleIdentityProvider
 * @extends BaseIdentityProvider<GoogleApplicationConfiguration>
 *
 * @property {string} [buttonText]
 * @property {string} [client_id]
 * @property {string} [client_secret]
 * @property {string} [scope]
 * @property {IdentityProviderType} [type]
 */


/**
 * Authorization Grant types as defined by the <a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization
 * Framework - RFC 6749</a>.
 * <p>
 * Specific names as defined by <a href="https://tools.ietf.org/html/rfc7591#section-4.1">
 * OAuth 2.0 Dynamic Client Registration Protocol - RFC 7591 Section 4.1</a>
 *
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var GrantType = {
  authorization_code: "authorization_code",
  implicit: "implicit",
  password: "password",
  client_credentials: "client_credentials",
  refresh_token: "refresh_token",
  unknown: "unknown"
};

/**
 * @author Tyler Scott
 *
 * @typedef {Object} Group
 *
 * @property {Object<string, Object>} [data]
 * @property {string} [id]
 * @property {string} [name]
 * @property {Object<string, Array<ApplicationRole>>} [roles]
 * @property {string} [tenantId]
 */


/**
 * A User's membership into a Group
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} GroupMember
 *
 * @property {Object<string, Object>} [data]
 * @property {string} [groupId]
 * @property {string} [id]
 * @property {number} [insertInstant]
 * @property {string} [userId]
 */


/**
 * Group API request object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} GroupRequest
 *
 * @property {Group} [group]
 * @property {Array<string>} [roleIds]
 */


/**
 * Group API response object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} GroupResponse
 *
 * @property {Group} [group]
 * @property {Array<Group>} [groups]
 */


/**
 * @typedef {Object} HistoryItem
 *
 * @property {string} [actionerUserId]
 * @property {string} [comment]
 * @property {number} [createInstant]
 * @property {number} [expiry]
 */


/**
 * Type for webhook headers.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} HTTPHeaders
 * @extends Object<string, string>
 *
 */


/**
 * Login API request object used for login to third-party systems (i.e. Login with Facebook).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} IdentityProviderLoginRequest
 * @extends BaseLoginRequest
 *
 * @property {Object<string, string>} [data]
 * @property {string} [encodedJWT]
 * @property {string} [identityProviderId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} IdentityProviderOauth2Configuration
 *
 * @property {string} [authorization_endpoint]
 * @property {string} [client_id]
 * @property {string} [client_secret]
 * @property {string} [issuer]
 * @property {string} [scope]
 * @property {string} [token_endpoint]
 * @property {string} [userinfo_endpoint]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} IdentityProviderRequest
 *
 * @property {BaseIdentityProvider<Object>} [identityProvider]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} IdentityProviderResponse
 *
 * @property {BaseIdentityProvider<Object>} [identityProvider]
 * @property {Array<BaseIdentityProvider<Object>>} [identityProviders]
 */


/**
 * @readonly
 * @enum
 */
var IdentityProviderType = {
  ExternalJWT: "ExternalJWT",
  OpenIDConnect: "OpenIDConnect",
  Facebook: "Facebook",
  Google: "Google",
  Twitter: "Twitter",
  SAMLv2: "SAMLv2"
};

/**
 * Import request.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} ImportRequest
 *
 * @property {string} [encryptionScheme]
 * @property {number} [factor]
 * @property {Array<User>} [users]
 * @property {boolean} [validateDbConstraints]
 */


/**
 * The Integration Request
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} IntegrationRequest
 *
 * @property {Integrations} [integrations]
 */


/**
 * The Integration Response
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} IntegrationResponse
 *
 * @property {Integrations} [integrations]
 */


/**
 * Available Integrations
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} Integrations
 *
 * @property {CleanSpeakConfiguration} [cleanspeak]
 * @property {KafkaConfiguration} [kafka]
 * @property {TwilioConfiguration} [twilio]
 */


/**
 * Counts for a period.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} IntervalCount
 *
 * @property {string} [applicationId]
 * @property {number} [count]
 * @property {number} [decrementedCount]
 * @property {number} [period]
 */


/**
 * A user over an period (for daily and monthly active user calculations).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} IntervalUser
 *
 * @property {string} [applicationId]
 * @property {number} [period]
 * @property {string} [userId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} IntrospectResponse
 * @extends Object<string, Object>
 *
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} IssueResponse
 *
 * @property {string} [refreshToken]
 * @property {string} [token]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} JWKSResponse
 *
 * @property {Array<Object>} [keys]
 */


/**
 * JWT Configuration. A JWT Configuration for an Application may not be active if it is using the global configuration, the configuration
 * may be <code>enabled = false</code>.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} JWTConfiguration
 * @extends Enableable
 *
 * @property {string} [accessTokenKeyId]
 * @property {string} [idTokenKeyId]
 * @property {number} [refreshTokenTimeToLiveInMinutes]
 * @property {number} [timeToLiveInSeconds]
 */


/**
 * Models the JWT public key Refresh Token Revoke Event (and can be converted to JSON). This event might be for a single
 * token, a user or an entire application.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} JWTPublicKeyUpdateEvent
 * @extends BaseEvent
 *
 * @property {Object<string>} [applicationIds]
 * @property {EventType} [type]
 */


/**
 * Models the Refresh Token Revoke Event (and can be converted to JSON). This event might be for a single token, a user
 * or an entire application.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} JWTRefreshTokenRevokeEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {Object<string, number>} [applicationTimeToLiveInSeconds]
 * @property {EventType} [type]
 * @property {string} [userId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} KafkaConfiguration
 * @extends Enableable
 *
 * @property {string} [defaultTopic]
 * @property {Object<string, string>} [producer]
 */


/**
 * Domain for a public key, key pair or an HMAC secret. This is used by KeyMaster to manage keys for JWTs, SAML, etc.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Key
 *
 * @property {KeyAlgorithm} [algorithm]
 * @property {string} [certificate]
 * @property {CertificateInformation} [certificateInformation]
 * @property {string} [displayName]
 * @property {number} [expirationInstant]
 * @property {string} [id]
 * @property {number} [insertInstant]
 * @property {string} [issuer]
 * @property {string} [kid]
 * @property {number} [length]
 * @property {string} [name]
 * @property {boolean} [pair]
 * @property {string} [privateKey]
 * @property {string} [publicKey]
 * @property {string} [secret]
 * @property {KeyType} [type]
 */


/**
 * @readonly
 * @enum
 */
var KeyAlgorithm = {
  ES256: "ES256",
  ES384: "ES384",
  ES512: "ES512",
  HS256: "HS256",
  HS384: "HS384",
  HS512: "HS512",
  RS256: "RS256",
  RS384: "RS384",
  RS512: "RS512"
};

/**
 * Key API request object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} KeyRequest
 *
 * @property {Key} [key]
 */


/**
 * Key API response object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} KeyResponse
 *
 * @property {Key} [key]
 * @property {Array<Key>} [keys]
 */


/**
 * @readonly
 * @enum
 */
var KeyType = {
  EC: "EC",
  RSA: "RSA",
  HMAC: "HMAC"
};

/**
 * A JavaScript lambda function that is executed during certain events inside FusionAuth.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Lambda
 * @extends Enableable
 *
 * @property {string} [body]
 * @property {boolean} [debug]
 * @property {string} [id]
 * @property {number} [insertInstant]
 * @property {string} [name]
 * @property {LambdaType} [type]
 */


/**
 * @typedef {Object} LambdaConfiguration
 *
 * @property {string} [accessTokenPopulateId]
 * @property {string} [idTokenPopulateId]
 * @property {string} [samlv2PopulateId]
 */


/**
 * @typedef {Object} LambdaConfiguration
 *
 * @property {string} [reconcileId]
 */


/**
 * Lambda API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} LambdaRequest
 *
 * @property {Lambda} [lambda]
 */


/**
 * Lambda API response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} LambdaResponse
 *
 * @property {Lambda} [lambda]
 * @property {Array<Lambda>} [lambdas]
 */


/**
 * The types of lambdas that indicate how they are invoked by FusionAuth.
 *
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var LambdaType = {
  JWTPopulate: "JWTPopulate",
  OpenIDReconcile: "OpenIDReconcile",
  SAMLv2Reconcile: "SAMLv2Reconcile",
  SAMLv2Populate: "SAMLv2Populate"
};

/**
 * Models a set of localized Strings that can be stored as JSON.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} LocalizedStrings
 * @extends Object<string, string>
 *
 */


/**
 * A historical state of a user log event. Since events can be modified, this stores the historical state.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} LogHistory
 *
 * @property {Array<HistoryItem>} [historyItems]
 */


/**
 * @typedef {Object} LoginConfiguration
 *
 * @property {boolean} [allowTokenRefresh]
 * @property {boolean} [generateRefreshTokens]
 * @property {boolean} [requireAuthentication]
 */


/**
 * @readonly
 * @enum
 */
var LoginIdType = {
  email: "email",
  username: "username"
};

/**
 * The summary of the action that is preventing login to be returned on the login response.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} LoginPreventedResponse
 *
 * @property {string} [actionerUserId]
 * @property {string} [actionId]
 * @property {number} [expiry]
 * @property {string} [localizedName]
 * @property {string} [localizedOption]
 * @property {string} [localizedReason]
 * @property {string} [name]
 * @property {string} [option]
 * @property {string} [reason]
 * @property {string} [reasonCode]
 */


/**
 * Response for the login report.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} LoginReportResponse
 *
 * @property {Array<Count>} [hourlyCounts]
 * @property {number} [total]
 */


/**
 * Login API request object.
 *
 * @author Seth Musselman
 *
 * @typedef {Object} LoginRequest
 * @extends BaseLoginRequest
 *
 * @property {string} [loginId]
 * @property {string} [oneTimePassword]
 * @property {string} [password]
 * @property {string} [twoFactorTrustId]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} LoginResponse
 *
 * @property {Array<LoginPreventedResponse>} [actions]
 * @property {string} [changePasswordId]
 * @property {string} [refreshToken]
 * @property {Object<string, Object>} [state]
 * @property {string} [token]
 * @property {string} [twoFactorId]
 * @property {string} [twoFactorTrustId]
 * @property {User} [user]
 */


/**
 * @typedef {Object} LoginTheme
 * @extends Enableable
 *
 * @property {string} [emailComplete]
 * @property {string} [emailSend]
 * @property {string} [emailVerify]
 * @property {string} [helpers]
 * @property {number} [lastModified]
 * @property {string} [oauth2Authorize]
 * @property {string} [oauth2CompleteRegistration]
 * @property {string} [oauth2Error]
 * @property {string} [oauth2Register]
 * @property {string} [oauth2TwoFactor]
 * @property {string} [passwordChange]
 * @property {string} [passwordComplete]
 * @property {string} [passwordForgot]
 * @property {string} [passwordSent]
 * @property {string} [registrationComplete]
 * @property {string} [registrationSend]
 * @property {string} [registrationVerify]
 * @property {string} [stylesheet]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} LookupResponse
 *
 * @property {BaseIdentityProvider<Object>} [identityProvider]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} MaximumPasswordAge
 * @extends Enableable
 *
 * @property {number} [days]
 */


/**
 * Group Member Delete Request
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} MemberDeleteRequest
 *
 * @property {Array<string>} [memberIds]
 * @property {Object<string, Array<string>>} [members]
 */


/**
 * Group Member Request
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} MemberRequest
 *
 * @property {Object<string, Array<GroupMember>>} [members]
 */


/**
 * Group Member Response
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} MemberResponse
 *
 * @property {Object<string, Array<GroupMember>>} [members]
 */


/**
 * @typedef {Object} MetaData
 *
 * @property {DeviceInfo} [device]
 * @property {Object<string>} [scopes]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} MinimumPasswordAge
 * @extends Enableable
 *
 * @property {number} [seconds]
 */


/**
 * Response for the daily active user report.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} MonthlyActiveUserReportResponse
 *
 * @property {Array<Count>} [monthlyActiveUsers]
 * @property {number} [total]
 */


/**
 * Helper methods for normalizing values.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Normalizer
 *
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OAuth2Configuration
 *
 * @property {Array<string>} [authorizedOriginURLs]
 * @property {Array<string>} [authorizedRedirectURLs]
 * @property {string} [clientId]
 * @property {string} [clientSecret]
 * @property {Object<GrantType>} [enabledGrants]
 * @property {boolean} [generateRefreshTokens]
 * @property {string} [logoutURL]
 * @property {boolean} [requireClientAuthentication]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OAuthConfigurationResponse
 *
 * @property {number} [httpSessionMaxInactiveInterval]
 * @property {string} [logoutURL]
 * @property {OAuth2Configuration} [oauthConfiguration]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OAuthError
 *
 * @property {string} [change_password_id]
 * @property {OAuthErrorType} [error]
 * @property {string} [error_description]
 * @property {OAuthErrorReason} [error_reason]
 * @property {string} [error_uri]
 * @property {string} [two_factor_id]
 */


/**
 * @readonly
 * @enum
 */
var OAuthErrorReason = {
  auth_code_not_found: "auth_code_not_found",
  access_token_malformed: "access_token_malformed",
  access_token_expired: "access_token_expired",
  access_token_unavailable_for_processing: "access_token_unavailable_for_processing",
  access_token_failed_processing: "access_token_failed_processing",
  refresh_token_not_found: "refresh_token_not_found",
  invalid_client_id: "invalid_client_id",
  invalid_user_credentials: "invalid_user_credentials",
  invalid_grant_type: "invalid_grant_type",
  invalid_origin: "invalid_origin",
  invalid_pkce_code_verifier_length: "invalid_pkce_code_verifier_length",
  invalid_pkce_code_challenge_length: "invalid_pkce_code_challenge_length",
  invalid_pkce_code_challenge_method: "invalid_pkce_code_challenge_method",
  invalid_redirect_uri: "invalid_redirect_uri",
  invalid_response_type: "invalid_response_type",
  grant_type_disabled: "grant_type_disabled",
  missing_client_id: "missing_client_id",
  missing_code: "missing_code",
  missing_grant_type: "missing_grant_type",
  missing_redirect_uri: "missing_redirect_uri",
  missing_refresh_token: "missing_refresh_token",
  missing_response_type: "missing_response_type",
  missing_token: "missing_token",
  login_prevented: "login_prevented",
  user_expired: "user_expired",
  user_not_found: "user_not_found",
  client_authentication_missing: "client_authentication_missing",
  invalid_client_authentication_scheme: "invalid_client_authentication_scheme",
  invalid_client_authentication: "invalid_client_authentication",
  client_id_mismatch: "client_id_mismatch",
  unknown: "unknown"
};

/**
 * @readonly
 * @enum
 */
var OAuthErrorType = {
  invalid_request: "invalid_request",
  invalid_client: "invalid_client",
  invalid_grant: "invalid_grant",
  invalid_token: "invalid_token",
  unauthorized_client: "unauthorized_client",
  invalid_scope: "invalid_scope",
  server_error: "server_error",
  unsupported_grant_type: "unsupported_grant_type",
  unsupported_response_type: "unsupported_response_type",
  change_password_required: "change_password_required",
  two_factor_required: "two_factor_required"
};

/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OAuthResponse
 *
 */


/**
 * OpenID Configuration as described by the <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID
 * Provider Metadata</a>.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} OpenIdConfiguration
 *
 * @property {string} [authorization_endpoint]
 * @property {Array<string>} [claims_supported]
 * @property {Array<string>} [grant_types_supported]
 * @property {Array<string>} [id_token_signing_alg_values_supported]
 * @property {string} [issuer]
 * @property {string} [jwks_uri]
 * @property {Array<string>} [response_types_supported]
 * @property {Array<string>} [scopes_supported]
 * @property {Array<string>} [subject_types_supported]
 * @property {string} [token_endpoint]
 * @property {Array<string>} [token_endpoint_auth_methods_supported]
 * @property {string} [userinfo_endpoint]
 * @property {Array<string>} [userinfo_signing_alg_values_supported]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OpenIdConnectApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 * @property {IdentityProviderOauth2Configuration} [oauth2]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} OpenIdConnectIdentityProvider
 * @extends BaseIdentityProvider<OpenIdConnectApplicationConfiguration>
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 * @property {Object<string>} [domains]
 * @property {LambdaConfiguration} [lambdaConfiguration]
 * @property {IdentityProviderOauth2Configuration} [oauth2]
 * @property {IdentityProviderType} [type]
 */


/**
 * Password Encryption Scheme Configuration
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} PasswordEncryptionConfiguration
 *
 * @property {string} [encryptionScheme]
 * @property {number} [encryptionSchemeFactor]
 * @property {boolean} [modifyEncryptionSchemeOnLogin]
 */


/**
 * @typedef {Object} PasswordlessConfiguration
 * @extends Enableable
 *
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} PasswordlessLoginRequest
 * @extends BaseLoginRequest
 *
 * @property {string} [code]
 * @property {string} [twoFactorTrustId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} PasswordlessSendRequest
 *
 * @property {string} [applicationId]
 * @property {string} [loginId]
 * @property {Object<string, Object>} [state]
 */


/**
 * @author Derek Klatt
 *
 * @typedef {Object} PasswordValidationRules
 *
 * @property {number} [maxLength]
 * @property {number} [minLength]
 * @property {RememberPreviousPasswords} [rememberPreviousPasswords]
 * @property {boolean} [requireMixedCase]
 * @property {boolean} [requireNonAlpha]
 * @property {boolean} [requireNumber]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} PasswordValidationRulesResponse
 *
 * @property {PasswordValidationRules} [passwordValidationRules]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} PreviewRequest
 *
 * @property {EmailTemplate} [emailTemplate]
 * @property {string} [locale]
 */


/**
 * @author Seth Musselman
 *
 * @typedef {Object} PreviewResponse
 *
 * @property {Email} [email]
 * @property {Errors} [errors]
 */


/**
 * JWT Public Key Response Object
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} PublicKeyResponse
 *
 * @property {string} [publicKey]
 * @property {Object<string, string>} [publicKeys]
 */


/**
 * Raw login information for each time a user logs into an application.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} RawLogin
 *
 * @property {string} [applicationId]
 * @property {number} [instant]
 * @property {string} [ipAddress]
 * @property {string} [userId]
 */


/**
 * Response for the user login report.
 *
 * @author Seth Musselman
 *
 * @typedef {Object} RecentLoginResponse
 *
 * @property {Array<DisplayableRawLogin>} [logins]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} RefreshRequest
 *
 * @property {string} [refreshToken]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} RefreshResponse
 *
 * @property {Array<RefreshToken>} [refreshTokens]
 * @property {string} [token]
 */


/**
 * Models a JWT Refresh Token.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} RefreshToken
 *
 * @property {Application} [application]
 * @property {string} [applicationId]
 * @property {number} [insertInstant]
 * @property {MetaData} [metaData]
 * @property {number} [startInstant]
 * @property {string} [token]
 * @property {string} [userId]
 */


/**
 * @typedef {Object} RegistrationConfiguration
 * @extends Enableable
 *
 * @property {Requirable} [birthDate]
 * @property {boolean} [confirmPassword]
 * @property {Requirable} [firstName]
 * @property {Requirable} [fullName]
 * @property {Requirable} [lastName]
 * @property {LoginIdType} [loginIdType]
 * @property {Requirable} [middleName]
 * @property {Requirable} [mobilePhone]
 */


/**
 * Response for the registration report.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} RegistrationReportResponse
 *
 * @property {Array<Count>} [hourlyCounts]
 * @property {number} [total]
 */


/**
 * Registration API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} RegistrationRequest
 *
 * @property {boolean} [generateAuthenticationToken]
 * @property {UserRegistration} [registration]
 * @property {boolean} [sendSetPasswordEmail]
 * @property {boolean} [skipRegistrationVerification]
 * @property {boolean} [skipVerification]
 * @property {User} [user]
 */


/**
 * Registration API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} RegistrationResponse
 *
 * @property {UserRegistration} [registration]
 * @property {User} [user]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} ReloadRequest
 *
 * @property {Array<string>} [names]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} RememberPreviousPasswords
 * @extends Enableable
 *
 * @property {number} [count]
 */


/**
 * Something that can be required and thus also optional. This currently extends Enableable because anything that is
 * require/optional is almost always enableable as well.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Requirable
 * @extends Enableable
 *
 * @property {boolean} [required]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} SAML2ApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 */


/**
 * SAML v2 identity provider configuration.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SAML2IdentityProvider
 * @extends BaseIdentityProvider<SAML2ApplicationConfiguration>
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 * @property {Object<string, string>} [claimMap]
 * @property {Object<string>} [domains]
 * @property {string} [emailClaim]
 * @property {string} [idpEndpoint]
 * @property {string} [requestPrivateKey]
 * @property {string} [requestPublicKey]
 * @property {string} [responsePublicKey]
 * @property {string} [rolesClaim]
 * @property {IdentityProviderType} [type]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} SAMLv2ApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 */


/**
 * @typedef {Object} SAMLv2Configuration
 * @extends Enableable
 *
 * @property {string} [audience]
 * @property {string} [callbackURL]
 * @property {boolean} [debug]
 * @property {string} [issuer]
 * @property {string} [keyId]
 * @property {string} [logoutURL]
 * @property {CanonicalizationMethod} [xmlSignatureC14nMethod]
 */


/**
 * SAML v2 identity provider configuration.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SAMLv2IdentityProvider
 * @extends BaseIdentityProvider<SAMLv2ApplicationConfiguration>
 *
 * @property {string} [buttonImageURL]
 * @property {string} [buttonText]
 * @property {Object<string>} [domains]
 * @property {string} [emailClaim]
 * @property {string} [idpEndpoint]
 * @property {string} [issuer]
 * @property {string} [keyId]
 * @property {LambdaConfiguration} [lambdaConfiguration]
 * @property {IdentityProviderType} [type]
 * @property {boolean} [useNameIdForEmail]
 */


/**
 * Search API request.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SearchRequest
 *
 * @property {UserSearchCriteria} [search]
 */


/**
 * Search API response.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SearchResponse
 *
 * @property {number} [total]
 * @property {Array<User>} [users]
 */


/**
 * Search results.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SearchResults
 * @template {T}
 *
 * @property {Array<T>} [results]
 * @property {number} [total]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} SecretResponse
 *
 * @property {string} [secret]
 * @property {string} [secretBase32Encoded]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} SecureIdentity
 *
 * @property {string} [encryptionScheme]
 * @property {number} [factor]
 * @property {string} [id]
 * @property {string} [password]
 * @property {boolean} [passwordChangeRequired]
 * @property {number} [passwordLastUpdateInstant]
 * @property {string} [salt]
 * @property {boolean} [verified]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} SendRequest
 *
 * @property {Array<string>} [bccAddresses]
 * @property {Array<string>} [ccAddresses]
 * @property {Object<string, Object>} [requestData]
 * @property {Array<string>} [userIds]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} SendResponse
 *
 * @property {Object<string, EmailTemplateErrors>} [results]
 */


/**
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var Sort = {
  asc: "asc",
  desc: "desc"
};

/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} SortField
 *
 * @property {string} [missing]
 * @property {string} [name]
 * @property {Sort} [order]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} SystemConfiguration
 *
 * @property {string} [cookieEncryptionIV]
 * @property {string} [cookieEncryptionKey]
 * @property {Object<string, Object>} [data]
 * @property {EmailConfiguration} [emailConfiguration]
 * @property {EventConfiguration} [eventConfiguration]
 * @property {EventLogConfiguration} [eventLogConfiguration]
 * @property {ExternalIdentifierConfiguration} [externalIdentifierConfiguration]
 * @property {FailedAuthenticationConfiguration} [failedAuthenticationConfiguration]
 * @property {number} [httpSessionMaxInactiveInterval]
 * @property {string} [issuer]
 * @property {JWTConfiguration} [jwtConfiguration]
 * @property {string} [logoutURL]
 * @property {MaximumPasswordAge} [maximumPasswordAge]
 * @property {MinimumPasswordAge} [minimumPasswordAge]
 * @property {PasswordEncryptionConfiguration} [passwordEncryptionConfiguration]
 * @property {PasswordValidationRules} [passwordValidationRules]
 * @property {string} [reportTimezone]
 * @property {UIConfiguration} [uiConfiguration]
 */


/**
 * Request for the system configuration API.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SystemConfigurationRequest
 *
 * @property {SystemConfiguration} [systemConfiguration]
 */


/**
 * Response for the system configuration API.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} SystemConfigurationResponse
 *
 * @property {SystemConfiguration} [systemConfiguration]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} Tenant
 *
 * @property {Object<string, Object>} [data]
 * @property {TenantEmailConfiguration} [emailConfiguration]
 * @property {string} [id]
 * @property {string} [name]
 */


/**
 * @typedef {Object} TenantEmailConfiguration
 * @extends Enableable
 *
 * @property {string} [forgotPasswordEmailTemplateId]
 * @property {string} [passwordlessEmailTemplateId]
 * @property {string} [setPasswordEmailTemplateId]
 * @property {string} [verificationEmailTemplateId]
 * @property {boolean} [verifyEmail]
 * @property {boolean} [verifyEmailWhenChanged]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TenantRequest
 *
 * @property {Tenant} [tenant]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TenantResponse
 *
 * @property {Tenant} [tenant]
 * @property {Array<Tenant>} [tenants]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TestEvent
 * @extends BaseEvent
 *
 * @property {string} [message]
 * @property {EventType} [type]
 */


/**
 * <ul>
 * <li>Bearer Token type as defined by <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>.</li>
 * <li>MAC Token type as referenced by <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> and
 * <a href="https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-05">
 * Draft RFC on OAuth 2.0 Message Authentication Code (MAC) Tokens</a>
 * </li>
 * </ul>
 *
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var TokenType = {
  Bearer: "Bearer",
  MAC: "MAC"
};

/**
 * @typedef {Object} Totals
 *
 * @property {number} [logins]
 * @property {number} [registrations]
 * @property {number} [totalRegistrations]
 */


/**
 * The response from the total report. This report stores the total numbers for each application.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} TotalsReportResponse
 *
 * @property {Object<string, Totals>} [applicationTotals]
 * @property {number} [globalRegistrations]
 * @property {number} [totalGlobalRegistrations]
 */


/**
 * The transaction types for Webhooks and other event systems within FusionAuth.
 *
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var TransactionType = {
  None: "None",
  Any: "Any",
  SimpleMajority: "SimpleMajority",
  SuperMajority: "SuperMajority",
  AbsoluteMajority: "AbsoluteMajority"
};

/**
 * Twilio Service Configuration.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} TwilioConfiguration
 * @extends Enableable
 *
 * @property {string} [accountSID]
 * @property {string} [authToken]
 * @property {string} [fromPhoneNumber]
 * @property {string} [messagingServiceSid]
 * @property {string} [url]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TwitterApplicationConfiguration
 * @extends BaseIdentityProviderApplicationConfiguration
 *
 * @property {string} [buttonText]
 * @property {string} [consumerKey]
 * @property {string} [consumerSecret]
 */


/**
 * Twitter social login provider.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} TwitterIdentityProvider
 * @extends BaseIdentityProvider<TwitterApplicationConfiguration>
 *
 * @property {string} [buttonText]
 * @property {string} [consumerKey]
 * @property {string} [consumerSecret]
 * @property {IdentityProviderType} [type]
 */


/**
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var TwoFactorDelivery = {
  None: "None",
  TextMessage: "TextMessage"
};

/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TwoFactorLoginRequest
 * @extends BaseLoginRequest
 *
 * @property {string} [code]
 * @property {boolean} [trustComputer]
 * @property {string} [twoFactorId]
 */


/**
 * @author Brian Pontarelli
 *
 * @typedef {Object} TwoFactorRequest
 *
 * @property {string} [code]
 * @property {TwoFactorDelivery} [delivery]
 * @property {string} [secret]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} TwoFactorSendRequest
 *
 * @property {string} [mobilePhone]
 * @property {string} [secret]
 * @property {string} [userId]
 */


/**
 * @typedef {Object} UIConfiguration
 *
 * @property {string} [headerColor]
 * @property {LoginTheme} [loginTheme]
 * @property {string} [logoURL]
 * @property {string} [menuFontColor]
 */


/**
 * The global view of a User. This object contains all global information about the user including birth date, registration information
 * preferred languages, global attributes, etc.
 *
 * @author Seth Musselman
 *
 * @typedef {Object} User
 * @extends SecureIdentity
 *
 * @property {boolean} [active]
 * @property {number} [age]
 * @property {string} [birthDate]
 * @property {string} [cleanSpeakId]
 * @property {Object<string, Object>} [data]
 * @property {string} [email]
 * @property {number} [expiry]
 * @property {string} [firstName]
 * @property {string} [fullName]
 * @property {string} [imageUrl]
 * @property {number} [insertInstant]
 * @property {number} [lastLoginInstant]
 * @property {string} [lastName]
 * @property {string} [login]
 * @property {Array<GroupMember>} [memberships]
 * @property {string} [middleName]
 * @property {string} [mobilePhone]
 * @property {string} [name]
 * @property {Array<string>} [preferredLanguages]
 * @property {Array<UserRegistration>} [registrations]
 * @property {string} [tenantId]
 * @property {string} [timezone]
 * @property {TwoFactorDelivery} [twoFactorDelivery]
 * @property {boolean} [twoFactorEnabled]
 * @property {string} [twoFactorSecret]
 * @property {string} [username]
 * @property {ContentStatus} [usernameStatus]
 */


/**
 * An action that can be executed on a user (discipline or reward potentially).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserAction
 *
 * @property {boolean} [active]
 * @property {string} [cancelEmailTemplateId]
 * @property {string} [endEmailTemplateId]
 * @property {string} [id]
 * @property {boolean} [includeEmailInEventJSON]
 * @property {LocalizedStrings} [localizedNames]
 * @property {string} [modifyEmailTemplateId]
 * @property {string} [name]
 * @property {Array<UserActionOption>} [options]
 * @property {boolean} [preventLogin]
 * @property {boolean} [sendEndEvent]
 * @property {string} [startEmailTemplateId]
 * @property {boolean} [temporal]
 * @property {TransactionType} [transactionType]
 * @property {boolean} [userEmailingEnabled]
 * @property {boolean} [userNotificationsEnabled]
 */


/**
 * Models the user action event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionEvent
 * @extends BaseEvent
 *
 * @property {string} [action]
 * @property {string} [actioneeUserId]
 * @property {string} [actionerUserId]
 * @property {string} [actionId]
 * @property {Array<string>} [applicationIds]
 * @property {string} [comment]
 * @property {Email} [email]
 * @property {boolean} [emailedUser]
 * @property {number} [expiry]
 * @property {string} [localizedAction]
 * @property {string} [localizedDuration]
 * @property {string} [localizedOption]
 * @property {string} [localizedReason]
 * @property {boolean} [notifyUser]
 * @property {string} [option]
 * @property {UserActionPhase} [phase]
 * @property {string} [reason]
 * @property {string} [reasonCode]
 * @property {EventType} [type]
 */


/**
 * A log for an action that was taken on a User.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionLog
 *
 * @property {string} [actioneeUserId]
 * @property {string} [actionerUserId]
 * @property {Array<string>} [applicationIds]
 * @property {string} [comment]
 * @property {number} [createInstant]
 * @property {boolean} [emailUserOnEnd]
 * @property {boolean} [endEventSent]
 * @property {number} [expiry]
 * @property {LogHistory} [history]
 * @property {string} [id]
 * @property {string} [localizedName]
 * @property {string} [localizedOption]
 * @property {string} [localizedReason]
 * @property {string} [name]
 * @property {boolean} [notifyUserOnEnd]
 * @property {string} [option]
 * @property {string} [reason]
 * @property {string} [reasonCode]
 * @property {string} [userActionId]
 */


/**
 * Models content user action options.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionOption
 *
 * @property {LocalizedStrings} [localizedNames]
 * @property {string} [name]
 */


/**
 * The phases of a time-based user action.
 *
 * @author Brian Pontarelli
 *
 * @readonly
 * @enum
 */
var UserActionPhase = {
  start: "start",
  modify: "modify",
  cancel: "cancel",
  end: "end"
};

/**
 * Models action reasons.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionReason
 *
 * @property {string} [code]
 * @property {string} [id]
 * @property {LocalizedStrings} [localizedTexts]
 * @property {string} [text]
 */


/**
 * User Action Reason API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionReasonRequest
 *
 * @property {UserActionReason} [userActionReason]
 */


/**
 * User Action Reason API response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionReasonResponse
 *
 * @property {UserActionReason} [userActionReason]
 * @property {Array<UserActionReason>} [userActionReasons]
 */


/**
 * User Action API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionRequest
 *
 * @property {UserAction} [userAction]
 */


/**
 * User Action API response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserActionResponse
 *
 * @property {UserAction} [userAction]
 * @property {Array<UserAction>} [userActions]
 */


/**
 * Models the User Bulk Create Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserBulkCreateEvent
 * @extends BaseEvent
 *
 * @property {EventType} [type]
 * @property {Array<User>} [users]
 */


/**
 * A log for an event that happened to a User.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserComment
 *
 * @property {string} [comment]
 * @property {string} [commenterId]
 * @property {number} [createInstant]
 * @property {string} [id]
 * @property {string} [userId]
 */


/**
 * @author Seth Musselman
 *
 * @typedef {Object} UserCommentRequest
 *
 * @property {UserComment} [userComment]
 */


/**
 * User Comment Response
 *
 * @author Seth Musselman
 *
 * @typedef {Object} UserCommentResponse
 *
 * @property {UserComment} [userComment]
 * @property {Array<UserComment>} [userComments]
 */


/**
 * Models the User Create Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserCreateEvent
 * @extends BaseEvent
 *
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * Models the User Deactivate Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserDeactivateEvent
 * @extends BaseEvent
 *
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * Models the User Event (and can be converted to JSON) that is used for all user modifications (create, update,
 * delete).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserDeleteEvent
 * @extends BaseEvent
 *
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * User API delete request object.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserDeleteRequest
 *
 * @property {boolean} [hardDelete]
 * @property {Array<string>} [userIds]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserinfoResponse
 * @extends Object<string, Object>
 *
 */


/**
 * Models the User Login Failed Event.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserLoginFailedEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {string} [authenticationType]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * Models the User Login Success Event.
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserLoginSuccessEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {string} [authenticationType]
 * @property {string} [identityProviderId]
 * @property {string} [identityProviderName]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * @typedef {Object} UsernameModeration
 * @extends Enableable
 *
 * @property {string} [applicationId]
 */


/**
 * Models the User Reactivate Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserReactivateEvent
 * @extends BaseEvent
 *
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * User registration information for a single application.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserRegistration
 *
 * @property {Application} [application]
 * @property {string} [applicationId]
 * @property {string} [authenticationToken]
 * @property {string} [cleanSpeakId]
 * @property {Object<string, Object>} [data]
 * @property {string} [id]
 * @property {number} [insertInstant]
 * @property {number} [lastLoginInstant]
 * @property {Array<string>} [preferredLanguages]
 * @property {Array<string>} [roles]
 * @property {string} [timezone]
 * @property {Object<string, string>} [tokens]
 * @property {string} [userId]
 * @property {string} [username]
 * @property {ContentStatus} [usernameStatus]
 * @property {boolean} [verified]
 */


/**
 * Models the User Create Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserRegistrationCreateEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {UserRegistration} [registration]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * Models the User Delete Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserRegistrationDeleteEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {UserRegistration} [registration]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * Models the User Update Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 *
 * @typedef {Object} UserRegistrationUpdateEvent
 * @extends BaseEvent
 *
 * @property {string} [applicationId]
 * @property {UserRegistration} [original]
 * @property {UserRegistration} [registration]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * User API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserRequest
 *
 * @property {boolean} [sendSetPasswordEmail]
 * @property {boolean} [skipVerification]
 * @property {User} [user]
 */


/**
 * User API response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserResponse
 *
 * @property {User} [user]
 */


/**
 * This class is the user query. It provides a build pattern as well as public fields for use on forms and in actions.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserSearchCriteria
 * @extends BaseSearchCriteria
 *
 * @property {string} [email]
 * @property {string} [fullName]
 * @property {string} [id]
 * @property {Array<string>} [ids]
 * @property {string} [queryString]
 * @property {Array<SortField>} [sortFields]
 * @property {string} [username]
 */


/**
 * @author Daniel DeGroff
 *
 * @readonly
 * @enum
 */
var UserState = {
  Authenticated: "Authenticated",
  AuthenticatedNotRegistered: "AuthenticatedNotRegistered"
};

/**
 * Models the User Update Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} UserUpdateEvent
 * @extends BaseEvent
 *
 * @property {User} [original]
 * @property {EventType} [type]
 * @property {User} [user]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} ValidateResponse
 *
 * @property {Object} [jwt]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} VerifyEmailResponse
 *
 * @property {string} [verificationId]
 */


/**
 * @author Daniel DeGroff
 *
 * @typedef {Object} VerifyRegistrationResponse
 *
 * @property {string} [verificationId]
 */


/**
 * A server where events are sent. This includes user action events and any other events sent by FusionAuth.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} Webhook
 *
 * @property {Array<string>} [applicationIds]
 * @property {number} [connectTimeout]
 * @property {WebhookData} [data]
 * @property {string} [description]
 * @property {boolean} [global]
 * @property {HTTPHeaders} [headers]
 * @property {string} [httpAuthenticationPassword]
 * @property {string} [httpAuthenticationUsername]
 * @property {string} [id]
 * @property {number} [readTimeout]
 * @property {string} [sslCertificate]
 * @property {string} [url]
 */


/**
 * @typedef {Object} WebhookData
 *
 * @property {Object<EventType, boolean>} [eventsEnabled]
 */


/**
 * Webhook API request object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} WebhookRequest
 *
 * @property {Webhook} [webhook]
 */


/**
 * Webhook API response object.
 *
 * @author Brian Pontarelli
 *
 * @typedef {Object} WebhookResponse
 *
 * @property {Webhook} [webhook]
 * @property {Array<Webhook>} [webhooks]
 */



module.exports = FusionAuthClient;